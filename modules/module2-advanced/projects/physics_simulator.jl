# Projet Module 2 : Simulateur de Physique
# Utilisation Avanc√©e de la R√©partition Multiple et des Structures de Donn√©es
# Temps estim√© : 2-3 heures

# üöÄ PROJET AVANC√â - AVANT DE COMMENCER
# OBLIGATOIRE : Lisez le r√©sum√© d'apprentissage : resume_projet_physics.md
# Ce projet exploite la pleine puissance de la r√©partition multiple de Julia
#
# Pr√©requis : Exercices 1 & 2 du Module 2 compl√©t√©s
# Ce projet d√©montre pourquoi Julia excelle dans le calcul scientifique

println("üöÄ PROJET AVANC√â : Simulateur de Physique Julia")
println("üìö Consultez OBLIGATOIREMENT le r√©sum√© : modules/module2-advanced/resume_projet_physics.md")
print("\nAvez-vous lu le r√©sum√© d'apprentissage ? (oui/non) : ")

if lowercase(readline()) != "oui"
    println("‚ö†Ô∏è  ARR√äT : Veuillez d'abord lire resume_projet_physics.md")
    println("Ce projet illustre la puissance de Julia pour le calcul scientifique.")
    exit()
end

using LinearAlgebra, Plots, Random
Random.seed!(42)  # Reproductibilit√©

println("üåå Simulateur de Physique : Syst√®mes Dynamiques")
println("="^60)

# Partie 1 : Hi√©rarchie de Types pour Objets Physiques
println("üèóÔ∏è Partie 1 : Architecture des Objets Physiques")

# Types abstraits pour la hi√©rarchie
abstract type ObjetPhysique end
abstract type Corps <: ObjetPhysique end
abstract type Force <: ObjetPhysique end
abstract type Contrainte <: ObjetPhysique end

# Types concrets pour les corps
mutable struct Particule <: Corps
    nom::String
    position::Vector{Float64}
    vitesse::Vector{Float64}
    acc√©l√©ration::Vector{Float64}
    masse::Float64
    rayon::Float64
    couleur::Symbol
    
    function Particule(nom, pos, vel, masse, rayon=0.1, couleur=:blue)
        new(nom, pos, vel, zeros(length(pos)), masse, rayon, couleur)
    end
end

mutable struct CorpsRigide <: Corps
    nom::String
    position::Vector{Float64}
    vitesse::Vector{Float64}
    acc√©l√©ration::Vector{Float64}
    masse::Float64
    moment_inertie::Float64
    orientation::Float64
    vitesse_angulaire::Float64
    points::Vector{Vector{Float64}}  # Forme du corps
    
    function CorpsRigide(nom, pos, vel, masse, inertie, points)
        new(nom, pos, vel, zeros(length(pos)), masse, inertie, 0.0, 0.0, points)
    end
end

# Types de forces
struct Gravit√© <: Force
    intensit√©::Float64
    direction::Vector{Float64}
end

struct ForceRessort <: Force
    k::Float64  # Constante de raideur
    longueur_repos::Float64
    extr√©mit√©_fixe::Vector{Float64}
end

struct ForceFrottement <: Force
    coefficient::Float64
end

struct ForceElectromagn√©tique <: Force
    charge::Float64
    champ::Vector{Float64}
end

# Partie 2 : Calculs de Forces avec R√©partition Multiple
println("‚ö° Partie 2 : Calculs de Forces Sp√©cialis√©es")

# Calcul de force g√©n√©rique
function calculer_force(force::Force, corps::Corps)
    return zeros(length(corps.position))  # Force nulle par d√©faut
end

# Sp√©cialisations pour chaque type de force
function calculer_force(gravit√©::Gravit√©, corps::Corps)
    return corps.masse * gravit√©.intensit√© * gravit√©.direction
end

function calculer_force(ressort::ForceRessort, corps::Corps)
    d√©placement = corps.position - ressort.extr√©mit√©_fixe
    distance = norm(d√©placement)
    if distance > 0
        direction = d√©placement / distance
        extension = distance - ressort.longueur_repos
        return -ressort.k * extension * direction
    else
        return zeros(length(corps.position))
    end
end

function calculer_force(frottement::ForceFrottement, corps::Corps)
    if norm(corps.vitesse) > 0
        return -frottement.coefficient * corps.masse * 9.81 * normalize(corps.vitesse)
    else
        return zeros(length(corps.position))
    end
end

function calculer_force(√©lectromag::ForceElectromagn√©tique, corps::Particule)
    # Force de Lorentz : F = q(E + v √ó B)
    force_√©lectrique = √©lectromag.charge * √©lectromag.champ
    # Simplification : pas de champ magn√©tique dans cette version
    return force_√©lectrique
end

# Partie 3 : Int√©gration Num√©rique avec M√©thodes Diff√©rentes
println("üßÆ Partie 3 : Int√©gration Num√©rique Adaptative")

# M√©thodes d'int√©gration
abstract type M√©thodeInt√©gration end

struct Euler <: M√©thodeInt√©gration end
struct RungeKutta4 <: M√©thodeInt√©gration end
struct Verlet <: M√©thodeInt√©gration end

# Int√©gration sp√©cialis√©e par m√©thode
function int√©grer!(corps::Corps, forces::Vector{Force}, dt::Float64, m√©thode::Euler)
    # M√©thode d'Euler simple
    force_totale = sum(calculer_force(f, corps) for f in forces)
    corps.acc√©l√©ration = force_totale / corps.masse
    
    corps.position += corps.vitesse * dt
    corps.vitesse += corps.acc√©l√©ration * dt
end

function int√©grer!(corps::Corps, forces::Vector{Force}, dt::Float64, m√©thode::RungeKutta4)
    # Runge-Kutta 4√®me ordre (simplifi√©)
    pos_init = copy(corps.position)
    vel_init = copy(corps.vitesse)
    
    # k1
    force_totale = sum(calculer_force(f, corps) for f in forces)
    k1_vel = dt * force_totale / corps.masse
    k1_pos = dt * corps.vitesse
    
    # k2
    corps.position = pos_init + k1_pos/2
    corps.vitesse = vel_init + k1_vel/2
    force_totale = sum(calculer_force(f, corps) for f in forces)
    k2_vel = dt * force_totale / corps.masse
    k2_pos = dt * corps.vitesse
    
    # k3
    corps.position = pos_init + k2_pos/2
    corps.vitesse = vel_init + k2_vel/2
    force_totale = sum(calculer_force(f, corps) for f in forces)
    k3_vel = dt * force_totale / corps.masse
    k3_pos = dt * corps.vitesse
    
    # k4
    corps.position = pos_init + k3_pos
    corps.vitesse = vel_init + k3_vel
    force_totale = sum(calculer_force(f, corps) for f in forces)
    k4_vel = dt * force_totale / corps.masse
    k4_pos = dt * corps.vitesse
    
    # Combinaison finale
    corps.position = pos_init + (k1_pos + 2*k2_pos + 2*k3_pos + k4_pos)/6
    corps.vitesse = vel_init + (k1_vel + 2*k2_vel + 2*k3_vel + k4_vel)/6
end

function int√©grer!(corps::Corps, forces::Vector{Force}, dt::Float64, m√©thode::Verlet)
    # M√©thode de Verlet pour syst√®mes conservatifs
    force_totale = sum(calculer_force(f, corps) for f in forces)
    nouvelle_acc√©l = force_totale / corps.masse
    
    corps.position += corps.vitesse * dt + 0.5 * corps.acc√©l√©ration * dt^2
    corps.vitesse += 0.5 * (corps.acc√©l√©ration + nouvelle_acc√©l) * dt
    corps.acc√©l√©ration = nouvelle_acc√©l
end

# Partie 4 : Syst√®me de Simulation Complet
println("üåç Partie 4 : Moteur de Simulation")

mutable struct Simulation
    corps::Vector{Corps}
    forces::Vector{Force}
    m√©thode::M√©thodeInt√©gration
    temps::Float64
    dt::Float64
    historique::Dict{String, Vector{Vector{Float64}}}
    
    function Simulation(m√©thode::M√©thodeInt√©gration = RungeKutta4(), dt = 0.01)
        new(Corps[], Force[], m√©thode, 0.0, dt, Dict{String, Vector{Vector{Float64}}}())
    end
end

function ajouter_corps!(sim::Simulation, corps::Corps)
    push!(sim.corps, corps)
    sim.historique[corps.nom] = [copy(corps.position)]
end

function ajouter_force!(sim::Simulation, force::Force)
    push!(sim.forces, force)
end

function simuler!(sim::Simulation, dur√©e::Float64)
    nombre_pas = Int(dur√©e / sim.dt)
    
    println("Simulation en cours... ($nombre_pas pas de temps)")
    for i in 1:nombre_pas
        # Int√©grer chaque corps
        for corps in sim.corps
            int√©grer!(corps, sim.forces, sim.dt, sim.m√©thode)
            push!(sim.historique[corps.nom], copy(corps.position))
        end
        
        sim.temps += sim.dt
        
        # Affichage de progression
        if i % (nombre_pas √∑ 10) == 0
            pourcentage = round(Int, 100 * i / nombre_pas)
            println("  Progression : $pourcentage%")
        end
    end
    
    println("Simulation termin√©e ! Temps total : $(sim.temps)s")
end

# Partie 5 : D√©tection de Collisions avec R√©partition Multiple
println("üí• Partie 5 : Syst√®me de Collisions")

function d√©tecter_collision(corps1::Particule, corps2::Particule)
    distance = norm(corps1.position - corps2.position)
    return distance < (corps1.rayon + corps2.rayon)
end

function d√©tecter_collision(corps::Particule, limite_x::Float64, limite_y::Float64)
    x, y = corps.position
    return abs(x) > limite_x || abs(y) > limite_y
end

function r√©soudre_collision!(corps1::Particule, corps2::Particule)
    # Collision √©lastique simple
    if d√©tecter_collision(corps1, corps2)
        # Vecteur de collision
        direction = normalize(corps1.position - corps2.position)
        
        # Vitesses relatives
        vitesse_rel = corps1.vitesse - corps2.vitesse
        vitesse_normale = dot(vitesse_rel, direction)
        
        # Ne r√©soudre que si les corps se rapprochent
        if vitesse_normale > 0
            return
        end
        
        # Conservation de la quantit√© de mouvement
        masse_totale = corps1.masse + corps2.masse
        impulsion = 2 * vitesse_normale / masse_totale
        
        corps1.vitesse -= impulsion * corps2.masse * direction
        corps2.vitesse += impulsion * corps1.masse * direction
        
        # S√©parer les corps pour √©viter la superposition
        recouvrement = (corps1.rayon + corps2.rayon) - norm(corps1.position - corps2.position)
        if recouvrement > 0
            s√©paration = recouvrement / 2 * direction
            corps1.position += s√©paration
            corps2.position -= s√©paration
        end
    end
end

# Partie 6 : Sc√©narios de Simulation Pr√©d√©finis
println("üé¨ Partie 6 : Sc√©narios de D√©monstration")

function cr√©er_syst√®me_solaire_simplifi√©()
    sim = Simulation(RungeKutta4(), 0.001)
    
    # Soleil (fixe au centre)
    soleil = Particule("Soleil", [0.0, 0.0], [0.0, 0.0], 1000.0, 0.5, :yellow)
    ajouter_corps!(sim, soleil)
    
    # Terre
    terre = Particule("Terre", [10.0, 0.0], [0.0, 3.0], 1.0, 0.2, :blue)
    ajouter_corps!(sim, terre)
    
    # Mars
    mars = Particule("Mars", [15.0, 0.0], [0.0, 2.5], 0.5, 0.15, :red)
    ajouter_corps!(sim, mars)
    
    # Force gravitationnelle universelle (simplifi√©e)
    gravit√© = Gravit√©(0.01, [0.0, 0.0])  # Sera calcul√©e pour chaque paire
    ajouter_force!(sim, gravit√©)
    
    return sim
end

function cr√©er_syst√®me_ressorts()
    sim = Simulation(Verlet(), 0.005)
    
    # Particules connect√©es par des ressorts
    p1 = Particule("P1", [-2.0, 0.0], [0.0, 0.0], 1.0, 0.1, :red)
    p2 = Particule("P2", [0.0, 0.0], [0.0, 0.0], 1.0, 0.1, :green)
    p3 = Particule("P3", [2.0, 0.0], [0.0, 0.0], 1.0, 0.1, :blue)
    
    ajouter_corps!(sim, p1)
    ajouter_corps!(sim, p2)
    ajouter_corps!(sim, p3)
    
    # Forces de ressort
    ressort1 = ForceRessort(50.0, 2.0, [-2.0, 0.0])  # Point fixe √† gauche
    ressort2 = ForceRessort(30.0, 2.0, [0.0, 2.0])   # Point fixe en haut
    
    ajouter_force!(sim, ressort1)
    ajouter_force!(sim, ressort2)
    
    # Gravit√©
    gravit√© = Gravit√©(9.81, [0.0, -1.0])
    ajouter_force!(sim, gravit√©)
    
    return sim
end

function cr√©er_syst√®me_collisions()
    sim = Simulation(Euler(), 0.01)
    
    # Particules avec vitesses al√©atoires
    for i in 1:5
        pos = [rand(-5:5), rand(-3:3)]
        vel = [rand(-2:0.1:2), rand(-2:0.1:2)]
        masse = rand(0.5:0.1:2.0)
        couleur = rand([:red, :blue, :green, :purple, :orange])
        
        particule = Particule("P$i", float.(pos), vel, masse, 0.3, couleur)
        ajouter_corps!(sim, particule)
    end
    
    # Frottement l√©ger
    frottement = ForceFrottement(0.1)
    ajouter_force!(sim, frottement)
    
    return sim
end

# Partie 7 : Visualisation et Analyse
println("üìä Partie 7 : Outils d'Analyse")

function analyser_√©nergie(sim::Simulation)
    √©nergies = Dict{String, Vector{Float64}}()
    
    for (nom, trajectoire) in sim.historique
        corps = findfirst(c -> c.nom == nom, sim.corps)
        if corps !== nothing
            c = sim.corps[corps]
            √©nergie_cin√©tique = Float64[]
            √©nergie_potentielle = Float64[]
            
            for pos in trajectoire
                # √ânergie cin√©tique
                ec = 0.5 * c.masse * norm(c.vitesse)^2
                push!(√©nergie_cin√©tique, ec)
                
                # √ânergie potentielle gravitationnelle (approximation)
                ep = c.masse * 9.81 * pos[2]  # mgh
                push!(√©nergie_potentielle, ep)
            end
            
            √©nergies[nom * "_cin√©tique"] = √©nergie_cin√©tique
            √©nergies[nom * "_potentielle"] = √©nergie_potentielle
        end
    end
    
    return √©nergies
end

function cr√©er_graphique_trajectoires(sim::Simulation, titre::String = "Trajectoires")
    p = plot(title=titre, xlabel="X", ylabel="Y", aspect_ratio=:equal)
    
    for (nom, trajectoire) in sim.historique
        if !isempty(trajectoire)
            x = [pos[1] for pos in trajectoire]
            y = [pos[2] for pos in trajectoire]
            
            # Trouver la couleur du corps
            corps = findfirst(c -> c.nom == nom, sim.corps)
            couleur = corps !== nothing ? sim.corps[corps].couleur : :black
            
            plot!(p, x, y, label=nom, linewidth=2, color=couleur)
            scatter!(p, [x[1]], [y[1]], color=couleur, markersize=8, label="", markershape=:circle)
            scatter!(p, [x[end]], [y[end]], color=couleur, markersize=8, label="", markershape=:star)
        end
    end
    
    return p
end

# Partie 8 : Interface de Contr√¥le Interactive
println("üéÆ Partie 8 : Interface de Contr√¥le")

function menu_simulation()
    println("\n" * "="^50)
    println("üéÆ MENU DE SIMULATION")
    println("="^50)
    println("1. Syst√®me solaire simplifi√©")
    println("2. Syst√®me de ressorts")
    println("3. Collisions de particules")
    println("4. Simulation personnalis√©e")
    println("5. Quitter")
    
    print("\nChoisissez un sc√©nario (1-5) : ")
    choix = readline()
    
    if choix == "1"
        println("üåå Lancement du syst√®me solaire...")
        sim = cr√©er_syst√®me_solaire_simplifi√©()
        simuler!(sim, 10.0)
        graphique = cr√©er_graphique_trajectoires(sim, "Syst√®me Solaire Simplifi√©")
        display(graphique)
        
    elseif choix == "2"
        println("üå∏ Lancement du syst√®me de ressorts...")
        sim = cr√©er_syst√®me_ressorts()
        simuler!(sim, 5.0)
        graphique = cr√©er_graphique_trajectoires(sim, "Syst√®me de Ressorts")
        display(graphique)
        
    elseif choix == "3"
        println("üí• Lancement des collisions de particules...")
        sim = cr√©er_syst√®me_collisions()
        simuler!(sim, 10.0)
        graphique = cr√©er_graphique_trajectoires(sim, "Collisions de Particules")
        display(graphique)
        
    elseif choix == "4"
        println("üîß Mode personnalisation - √Ä impl√©menter...")
        println("Conseil : Modifiez les fonctions cr√©er_syst√®me_* pour vos propres exp√©riences !")
        
    elseif choix == "5"
        println("üëã Au revoir !")
        return false
    else
        println("‚ùå Choix invalide !")
    end
    
    return true
end

# Lancement de l'interface
continuer = true
while continuer
    global continuer = menu_simulation()
    if continuer
        print("\nAppuyez sur Entr√©e pour continuer...")
        readline()
    end
end

# Bilan d'apprentissage du projet
println("\nüìà BILAN D'APPRENTISSAGE - PROJET SIMULATEUR")
println("="^70)
println("üöÄ MA√éTRISE EXPERTE DE LA PROGRAMMATION JULIA AVANC√âE !")
println("="^70)
println("‚úÖ Comp√©tences de niveau ing√©nieur d√©velopp√©es :")
println("  üèóÔ∏è Architecture complexe avec hi√©rarchie de types abstraits")
println("  üé≠ Exploitation avanc√©e de la r√©partition multiple")
println("  üßÆ Impl√©mentation de m√©thodes num√©riques sp√©cialis√©es")
println("  ‚ö° Optimisation de performance par sp√©cialisation de types")
println("  üí• Syst√®mes de collision et d√©tection g√©om√©trique")
println("  üìä Visualisation et analyse de donn√©es scientifiques")
println("  üéÆ Interface utilisateur interactive complexe")

println("\nüåü BADGE D√âBLOQU√â : 'Ing√©nieur Julia Syst√®mes Dynamiques'")
println("Vous pouvez maintenant tackle des projets de calcul scientifique r√©els !")

println("\nüéØ APPLICATIONS DIRECTES DE CET APPRENTISSAGE :")
println("  - Simulations de syst√®mes physiques complexes")
println("  - Mod√©lisation de dynamiques financi√®res") 
println("  - Syst√®mes multi-agents et intelligence artificielle")
println("  - Jeux vid√©o avec physique r√©aliste")
println("  - Recherche en m√©canique et ing√©nierie")

println("\nüöÄ PR√äT POUR LE MODULE 3 - MACHINE LEARNING")
println("Vos comp√©tences en structures de donn√©es et r√©partition multiple")
println("sont exactement ce qu'il faut pour exceller en ML avec Julia !")

println("\nüìö POUR ALLER PLUS LOIN :")
println("  - Explorez DifferentialEquations.jl pour des solveurs avanc√©s")
println("  - D√©couvrez Makie.jl pour de la visualisation 3D interactive")
println("  - Consultez les paquets de calcul scientifique Julia")
println("="^70)