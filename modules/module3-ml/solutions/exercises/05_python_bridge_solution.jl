# Exercice 5 : Bridge Python-Julia
# Module 3 : Apprentissage Automatique avec Julia
# Dur√©e : 45 minutes

# üìö AVANT DE COMMENCER
# Lisez le r√©sum√© d'apprentissage : resume_05_python_bridge.md
# D√©couvrez comment combiner le meilleur des √©cosyst√®mes Python et Julia !

println("üìö Consultez le r√©sum√© : modules/module3-ml/resume_05_python_bridge.md")
println("Appuyez sur Entr√©e quand vous √™tes pr√™t √† unir Python et Julia...")
readline()

println("üêçüîó Bridge Python-Julia : Le Meilleur des Deux Mondes")
println("="^70)

# Installation et configuration des paquets n√©cessaires
println("üîß Configuration de l'environnement Python-Julia...")

# Paquets Julia
using PyCall, DataFrames, CSV
using Plots, Statistics, Random
using Conda  # Pour g√©rer l'environnement Python

# Configuration pour reproductibilit√©
Random.seed!(42)

println("‚úÖ Environnement Julia configur√©")

# Partie 1 : Configuration et Test de PyCall
println("\nüîå Partie 1 : Configuration PyCall et Test de Base")

# V√©rifier la configuration Python
println("Version Python utilis√©e par PyCall :")
println("Python : $(PyCall.python)")
println("Version : $(PyCall.pyversion)")

# Installer des paquets Python si n√©cessaire
println("\nInstallation des paquets Python requis...")

# V√©rifier et installer pandas si n√©cessaire
try
    pandas = pyimport("pandas")
    println("‚úÖ Pandas d√©j√† disponible")
catch
    println("üì¶ Installation de pandas...")
    try
        Conda.add("pandas")
        pandas = pyimport("pandas")
        println("‚úÖ Pandas install√© avec succ√®s")
    catch e
        println("‚ö†Ô∏è Impossible d'installer pandas automatiquement : $e")
        println("Veuillez installer pandas manuellement dans votre environnement Python")
    end
end

# V√©rifier et installer scikit-learn
try
    sklearn = pyimport("sklearn")
    println("‚úÖ Scikit-learn d√©j√† disponible")
catch
    println("üì¶ Installation de scikit-learn...")
    try
        Conda.add("scikit-learn")
        sklearn = pyimport("sklearn")
        println("‚úÖ Scikit-learn install√© avec succ√®s")
    catch e
        println("‚ö†Ô∏è Installation scikit-learn √©chou√©e : $e")
        println("Continuons avec les fonctions de base Python")
    end
end

# Test de base avec Python
println("\nüß™ Tests de fonctionnement de base...")

# Appeler des fonctions Python natives
py"""
def calculer_statistiques_bf(donn√©es):
    \"\"\"Calculer des statistiques pour donn√©es burkinab√®\"\"\"
    import numpy as np
    
    moyenne = np.mean(donn√©es)
    m√©diane = np.median(donn√©es)
    √©cart_type = np.std(donn√©es)
    
    return {
        'moyenne': moyenne,
        'm√©diane': m√©diane,
        '√©cart_type': √©cart_type,
        'n_observations': len(donn√©es)
    }

def convertir_fcfa_euro(montant_fcfa, taux=656):
    \"\"\"Convertir FCFA vers Euro\"\"\"
    return montant_fcfa / taux
"""

# Donn√©es d'exemple : PIB par habitant en FCFA par r√©gion BF
pib_regions_fcfa = [450000, 380000, 850000, 320000, 290000, 
                    410000, 360000, 310000, 520000, 270000,
                    480000, 250000, 420000]

r√©gions_bf = ["Boucle du Mouhoun", "Cascades", "Centre", "Centre-Est", "Centre-Nord",
              "Centre-Ouest", "Centre-Sud", "Est", "Hauts-Bassins", "Nord",
              "Plateau-Central", "Sahel", "Sud-Ouest"]

# Appeler la fonction Python depuis Julia
stats_pib = py"calculer_statistiques_bf"(pib_regions_fcfa)

println("Statistiques PIB par habitant Burkina Faso (FCFA) :")
println("  Moyenne : $(round(Int, stats_pib["moyenne"])) FCFA")
println("  M√©diane : $(round(Int, stats_pib["m√©diane"])) FCFA")
println("  √âcart-type : $(round(Int, stats_pib["√©cart_type"])) FCFA")
println("  R√©gions : $(stats_pib["n_observations"])")

# Conversion en Euro
pib_euros = [py"convertir_fcfa_euro"(pib) for pib in pib_regions_fcfa]
println("\nPIB moyen en Euro : $(round(mean(pib_euros), digits=0)) ‚Ç¨/habitant")

# Partie 2 : √âchange de Donn√©es entre Julia et Python
println("\nüìä Partie 2 : √âchange de DataFrames Julia ‚Üî Pandas")

# Cr√©er un DataFrame Julia avec des donn√©es agricoles BF
donn√©es_agri_bf = DataFrame(
    r√©gion = r√©p√©tition_r√©gions_bf = repeat(r√©gions_bf, 3),
    culture = repeat(["Mil", "Sorgho", "Ma√Øs"], inner=13),
    superficie_ha = rand(500:5000, 39),
    rendement_tha = [
        # Mil (plus r√©sistant √† la s√©cheresse)
        0.6 .+ rand(13) * 0.4,  # 0.6-1.0 t/ha
        # Sorgho (bon rendement)
        0.8 .+ rand(13) * 0.4,  # 0.8-1.2 t/ha  
        # Ma√Øs (plus sensible mais productif)
        0.9 .+ rand(13) * 0.6   # 0.9-1.5 t/ha
    ] |> x -> vcat(x...),
    pluie_mm = repeat([300, 600, 900], inner=13) .+ rand(39) * 200,
    prix_fcfa_kg = [
        repeat([200], 13),  # Mil
        repeat([180], 13),  # Sorgho
        repeat([220], 13)   # Ma√Øs
    ] |> x -> vcat(x...) .+ rand(39) * 50
)

# Calculer production totale et revenus
donn√©es_agri_bf.production_totale = donn√©es_agri_bf.superficie_ha .* donn√©es_agri_bf.rendement_tha
donn√©es_agri_bf.revenus_fcfa = donn√©es_agri_bf.production_totale .* donn√©es_agri_bf.prix_fcfa_kg

println("DataFrame Julia cr√©√© : $(nrow(donn√©es_agri_bf)) observations")
println("Colonnes : $(join(names(donn√©es_agri_bf), ", "))")

# Convertir Julia DataFrame vers Pandas si possible
pandas_disponible = false
df_pandas = nothing

try
    pandas = pyimport("pandas")
    pandas_disponible = true
    
    # Conversion Julia ‚Üí Pandas
    println("\nüêç Conversion Julia DataFrame ‚Üí Pandas...")
    
    # M√©thode 1 : Via dictionnaire
    dict_donn√©es = Dict()
    for col in names(donn√©es_agri_bf)
        dict_donn√©es[col] = donn√©es_agri_bf[!, col]
    end
    
    df_pandas = pandas.DataFrame(dict_donn√©es)
    println("‚úÖ Conversion r√©ussie vers Pandas")
    println("Shape Pandas : $(df_pandas.shape)")
    
    # Op√©rations Pandas depuis Julia
    println("\nüîß Op√©rations Pandas depuis Julia...")
    
    # Groupby avec Pandas
    groupby_culture = df_pandas.groupby("culture")
    stats_pandas = groupby_culture.agg(py"""
    {
        'rendement_tha': ['mean', 'std'],
        'revenus_fcfa': ['mean', 'sum']
    }
    """)
    
    println("Statistiques par culture (calcul√©es avec Pandas) :")
    println(stats_pandas)
    
catch e
    println("‚ö†Ô∏è Pandas non disponible, continuons sans conversion : $e")
end

# Partie 3 : Utilisation de Scikit-learn depuis Julia
println("\nü§ñ Partie 3 : Scikit-learn depuis Julia")

sklearn_disponible = false

try
    # Importer scikit-learn
    sklearn_ensemble = pyimport("sklearn.ensemble")
    sklearn_model_selection = pyimport("sklearn.model_selection")
    sklearn_metrics = pyimport("sklearn.metrics")
    
    sklearn_disponible = true
    println("‚úÖ Scikit-learn disponible")
    
    # Pr√©parer les donn√©es pour ML (pr√©dire le rendement)
    println("\nPr√©paration des donn√©es pour Random Forest (scikit-learn)...")
    
    # Features : superficie, pluie, prix
    X = hcat(donn√©es_agri_bf.superficie_ha, donn√©es_agri_bf.pluie_mm, donn√©es_agri_bf.prix_fcfa_kg)
    y = donn√©es_agri_bf.rendement_tha
    
    println("Features : $(size(X, 2)) variables, $(size(X, 1)) observations")
    
    # Train/test split avec scikit-learn
    train_test = sklearn_model_selection.train_test_split(X, y, test_size=0.3, random_state=42)
    X_train, X_test, y_train, y_test = train_test
    
    println("Train : $(size(X_train, 1)) obs, Test : $(size(X_test, 1)) obs")
    
    # Cr√©er et entra√Æner Random Forest
    println("\nüå≤ Random Forest avec scikit-learn...")
    rf_sklearn = sklearn_ensemble.RandomForestRegressor(
        n_estimators=50,
        random_state=42,
        max_depth=5
    )
    
    # Entra√Ænement
    rf_sklearn.fit(X_train, y_train)
    println("‚úÖ Mod√®le Random Forest entra√Æn√©")
    
    # Pr√©dictions
    y_pred_sklearn = rf_sklearn.predict(X_test)
    
    # M√©triques avec scikit-learn
    mae_sklearn = sklearn_metrics.mean_absolute_error(y_test, y_pred_sklearn)
    r2_sklearn = sklearn_metrics.r2_score(y_test, y_pred_sklearn)
    
    println("Performance scikit-learn Random Forest :")
    println("  MAE : $(round(mae_sklearn, digits=3)) t/ha")
    println("  R¬≤ : $(round(r2_sklearn, digits=3))")
    
    # Feature importance depuis scikit-learn
    feature_names = ["Superficie (ha)", "Pluie (mm)", "Prix (FCFA/kg)"]
    importances = rf_sklearn.feature_importances_
    
    println("\nImportance des variables :")
    for (name, importance) in zip(feature_names, importances)
        println("  $name : $(round(importance * 100, digits=1))%")
    end
    
    # Pr√©diction pour un sc√©nario BF typique
    # Petit producteur : 2 ha, 600mm pluie, prix moyen
    sc√©nario_bf = reshape([2000, 600, 200], 1, :)  # reshape pour scikit-learn
    pr√©diction_bf = rf_sklearn.predict(sc√©nario_bf)[1]  # Premier √©l√©ment
    
    println("\nüåæ Pr√©diction pour petit producteur burkinab√® :")
    println("  Sc√©nario : 2 ha, 600mm pluie, 200 FCFA/kg")
    println("  Rendement pr√©dit : $(round(pr√©diction_bf, digits=2)) t/ha")
    
    revenus_pr√©vus = 2000 * pr√©diction_bf * 200  # superficie * rendement * prix
    println("  Revenus pr√©vus : $(round(Int, revenus_pr√©vus)) FCFA")
    println("  Revenus en Euro : $(round(revenus_pr√©vus / 656, digits=0)) ‚Ç¨")
    
catch e
    println("‚ö†Ô∏è Scikit-learn non disponible : $e")
    println("Continuons avec les autres fonctionnalit√©s...")
end

# Partie 4 : Visualisation Combin√©e Julia + Python
println("\nüìä Partie 4 : Visualisation Hybride")

# Graphique Julia avec Plots.jl
println("Cr√©ation de graphiques avec Plots.jl...")

p1 = scatter(donn√©es_agri_bf.pluie_mm, donn√©es_agri_bf.rendement_tha,
    group=donn√©es_agri_bf.culture,
    title="Rendement vs Pr√©cipitations - Burkina Faso",
    xlabel="Pr√©cipitations (mm)",
    ylabel="Rendement (t/ha)",
    legend=:topleft,
    size=(700, 400))

display(p1)

# Utiliser matplotlib depuis Julia si disponible
try
    plt = pyimport("matplotlib.pyplot")
    numpy = pyimport("numpy")
    
    println("‚úÖ Matplotlib disponible, cr√©ation d'un graphique Python...")
    
    # Cr√©er un graphique avec matplotlib depuis Julia
    py"""
    import matplotlib.pyplot as plt
    import numpy as np
    
    def cr√©er_histogramme_revenus(revenus, r√©gions, titre):
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Histogramme des revenus
        ax.bar(range(len(r√©gions)), revenus, color='green', alpha=0.7)
        ax.set_xlabel('R√©gions')
        ax.set_ylabel('Revenus Moyens (FCFA)')
        ax.set_title(titre)
        ax.set_xticks(range(len(r√©gions)))
        ax.set_xticklabels(r√©gions, rotation=45, ha='right')
        
        # Ligne de moyenne
        moyenne = np.mean(revenus)
        ax.axhline(y=moyenne, color='red', linestyle='--', 
                   label=f'Moyenne: {moyenne:,.0f} FCFA')
        ax.legend()
        
        plt.tight_layout()
        return fig
    """
    
    # Calculer revenus moyens par r√©gion
    revenus_par_r√©gion = combine(groupby(donn√©es_agri_bf, :r√©gion), :revenus_fcfa => mean => :revenus_moyen)
    sort!(revenus_par_r√©gion, :revenus_moyen, rev=true)
    
    # Cr√©er le graphique Python depuis Julia
    fig_python = py"cr√©er_histogramme_revenus"(
        revenus_par_r√©gion.revenus_moyen,
        revenus_par_r√©gion.r√©gion,
        "Revenus Agricoles Moyens par R√©gion - Burkina Faso"
    )
    
    # Sauvegarder (optionnel)
    try
        fig_python.savefig("revenus_regions_bf_matplotlib.png", dpi=150, bbox_inches="tight")
        println("üìä Graphique matplotlib sauvegard√© : revenus_regions_bf_matplotlib.png")
    catch
        println("‚ö†Ô∏è Sauvegarde graphique matplotlib √©chou√©e")
    end
    
catch e
    println("‚ö†Ô∏è Matplotlib non disponible : $e")
end

# Partie 5 : Calculs Num√©riques Avanc√©s
println("\nüî¢ Partie 5 : Calculs Num√©riques Hybrides")

# Utiliser NumPy pour des calculs puis traiter en Julia
try
    numpy = pyimport("numpy")
    
    println("üßÆ Calculs avec NumPy depuis Julia...")
    
    # Simulation Monte Carlo avec NumPy
    py"""
    import numpy as np
    
    def simulation_monte_carlo_r√©colte(n_simulations=10000):
        '''Simulation des risques de r√©colte au Burkina Faso'''
        np.random.seed(42)
        
        # Param√®tres climatiques (distributions r√©alistes)
        pluie = np.random.normal(600, 200, n_simulations)  # Moyenne 600mm ¬±200
        pluie = np.clip(pluie, 200, 1200)  # Limites r√©alistes
        
        # Temp√©rature (impact sur rendement)
        temp√©rature = np.random.normal(30, 5, n_simulations)
        temp√©rature = np.clip(temp√©rature, 20, 45)
        
        # Calcul rendement bas√© sur mod√®le simple
        # Rendement optimal vers 600-800mm pluie et 25-35¬∞C
        facteur_pluie = np.where(pluie < 600, pluie/600, 
                                np.where(pluie > 800, 0.8 + 0.2*(1200-pluie)/400, 1.0))
        
        facteur_temp = np.where(temp√©rature < 35, 1.0, 1.0 - (temp√©rature-35)*0.05)
        facteur_temp = np.clip(facteur_temp, 0.3, 1.0)
        
        # Rendement final (base 1 t/ha)
        rendement = 1.0 * facteur_pluie * facteur_temp * np.random.uniform(0.8, 1.2, n_simulations)
        rendement = np.clip(rendement, 0.1, 2.0)
        
        return {
            'pluie': pluie,
            'temp√©rature': temp√©rature, 
            'rendement': rendement
        }
    """
    
    # Ex√©cuter la simulation
    r√©sultats_monte_carlo = py"simulation_monte_carlo_r√©colte"(5000)
    
    # Traiter les r√©sultats en Julia
    pluie_sim = r√©sultats_monte_carlo["pluie"]
    temp_sim = r√©sultats_monte_carlo["temp√©rature"]
    rendement_sim = r√©sultats_monte_carlo["rendement"]
    
    println("Simulation Monte Carlo (5000 sc√©narios) :")
    println("  Rendement moyen : $(round(mean(rendement_sim), digits=2)) t/ha")
    println("  Rendement m√©dian : $(round(median(rendement_sim), digits=2)) t/ha")
    println("  √âcart-type : $(round(std(rendement_sim), digits=2)) t/ha")
    
    # Probabilit√©s de seuils critiques
    prob_√©chec = mean(rendement_sim .< 0.5) * 100  # Moins de 0.5 t/ha
    prob_bon = mean(rendement_sim .> 1.2) * 100    # Plus de 1.2 t/ha
    
    println("  Probabilit√© d'√©chec (<0.5 t/ha) : $(round(prob_√©chec, digits=1))%")
    println("  Probabilit√© de bonne r√©colte (>1.2 t/ha) : $(round(prob_bon, digits=1))%")
    
    # Graphique de distribution avec Julia
    p_monte_carlo = histogram(rendement_sim, bins=30,
        title="Distribution des Rendements - Simulation Monte Carlo BF",
        xlabel="Rendement (t/ha)",
        ylabel="Fr√©quence",
        color=:green,
        alpha=0.7,
        size=(700, 400))
    
    # Ajouter lignes de seuils
    vline!([0.5], color=:red, linewidth=2, linestyle=:dash, label="Seuil d'√©chec")
    vline!([1.2], color=:blue, linewidth=2, linestyle=:dash, label="Bon rendement")
    
    display(p_monte_carlo)
    
catch e
    println("‚ö†Ô∏è Calculs NumPy non disponibles : $e")
end

# Partie 6 : Int√©gration Compl√®te et Bonnes Pratiques
println("\nüéØ Partie 6 : Bonnes Pratiques d'Int√©gration")

println("""
üîó STRAT√âGIES D'INT√âGRATION PYTHON-JULIA OPTIMALES :

‚úÖ QUAND UTILISER PYTHON DEPUIS JULIA :
  ‚Ä¢ Biblioth√®ques sp√©cialis√©es non disponibles en Julia
  ‚Ä¢ √âcosyst√®me mature (ex: scikit-learn pour prototypage rapide)
  ‚Ä¢ Interface avec syst√®mes Python existants
  ‚Ä¢ Visualisations sp√©cialis√©es (seaborn, plotly)

‚úÖ QUAND RESTER EN JULIA PUR :
  ‚Ä¢ Performance critique (calculs intensifs)
  ‚Ä¢ Nouvelle architecture (exploiter multiple dispatch)
  ‚Ä¢ √âcosyst√®me Julia mature (MLJ.jl, Flux.jl)
  ‚Ä¢ Manipulation de types complexes

üéØ APPROCHE HYBRIDE RECOMMAND√âE :
  1. Prototypage rapide avec Python
  2. Migration vers Julia pour la production
  3. Conservation des outils de visualisation Python
  4. Interface Julia pour utilisateurs finaux
""")

# D√©monstration : Comparaison performance Julia vs Python
println("\n‚ö° Comparaison Performance Julia vs Python")

# Fonction de calcul intensif en Julia
function calcul_intensif_julia(n::Int)
    total = 0.0
    for i in 1:n
        total += sqrt(i) * sin(i)
    end
    return total
end

# M√™me fonction en Python
py"""
import math

def calcul_intensif_python(n):
    total = 0.0
    for i in range(1, n+1):
        total += math.sqrt(i) * math.sin(i)
    return total
"""

# Benchmark (sur un calcul plus petit pour √©viter les timeouts)
n_test = 100000

println("Test de performance (n = $n_test) :")

# Julia
temps_julia = @elapsed r√©sultat_julia = calcul_intensif_julia(n_test)

# Python
temps_python = @elapsed r√©sultat_python = py"calcul_intensif_python"(n_test)

println("  Julia : $(round(temps_julia * 1000, digits=1)) ms")
println("  Python : $(round(temps_python * 1000, digits=1)) ms")
println("  Speedup Julia : $(round(temps_python / temps_julia, digits=1))x plus rapide")
println("  Diff√©rence r√©sultats : $(abs(r√©sultat_julia - r√©sultat_python))")

# Recommandations finales
println("\nüí° RECOMMANDATIONS POUR PROJETS BURKINA FASO :")
println("""
üåæ AGRICULTURE :
  ‚Ä¢ Prototypage mod√®les avec scikit-learn
  ‚Ä¢ Production avec MLJ.jl (performance)  
  ‚Ä¢ Visualisation Matplotlib + Plots.jl
  
üå°Ô∏è CLIMAT :
  ‚Ä¢ Traitement donn√©es avec Pandas (familiarit√©)
  ‚Ä¢ Calculs NumPy ‚Üí Julia pour performance
  ‚Ä¢ Dashboards avec Julia Genie.jl

üìä FINANCE/√âCONOMIE :
  ‚Ä¢ Excel/CSV ‚Üí Pandas ‚Üí DataFrames.jl
  ‚Ä¢ Calculs √©conomiques en Julia (pr√©cision)
  ‚Ä¢ Rapports avec Python (√©cosyst√®me mature)
""")

# Bilan d'apprentissage
println("\nüìà BILAN D'APPRENTISSAGE")
println("="^70)
println("üêçüîó MA√éTRISE DE L'INT√âGRATION PYTHON-JULIA !")
println("="^70)
println("‚úÖ Comp√©tences d'int√©gration d√©velopp√©es :")
println("  üîß Configuration et utilisation de PyCall.jl")
println("  üêç Ex√©cution de code Python depuis Julia")
println("  üìä Conversion DataFrames Julia ‚Üî Pandas") 
println("  ü§ñ Utilisation de scikit-learn depuis Julia")
println("  üìà Visualisation hybride Plots.jl + Matplotlib")
println("  üî¢ Calculs NumPy avec post-traitement Julia")
println("  ‚ö° Optimisation performance avec choix technologique √©clair√©")
println("  üáßüá´ Applications pratiques contextualis√©es Burkina Faso")

println("\nüåü BADGE D√âBLOQU√â : 'Architecte Multi-√âcosyst√®me BF'")
println("Vous ma√Ætrisez maintenant l'art de combiner le meilleur")
println("des √©cosyst√®mes Python et Julia !")

println("\nüéØ COMP√âTENCES PROFESSIONNELLES UNIQUES :")
println("  - Int√©gration de syst√®mes ML existants (Python) avec performance Julia")
println("  - Migration progressive Python ‚Üí Julia pour organisations")
println("  - D√©veloppement d'APIs hybrides haute performance")
println("  - Conseil technologique √©clair√© par l'exp√©rience pratique")

println("\nüöÄ PR√äT POUR LES PROJETS FINAUX !")
println("üìÜ PROCHAINES √âTAPES : Projets agricole et climatique")
println("   (Combinez tout : MLJ, visualisation, et int√©gration Python)")
println("   (Conseil : Choisissez la technologie optimale pour chaque t√¢che !)")