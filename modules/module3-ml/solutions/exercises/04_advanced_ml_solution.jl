# Exercice 4 : Machine Learning Avanc√© avec Julia
# Module 3 : Apprentissage Automatique avec Julia
# Dur√©e : 75 minutes

# üìö AVANT DE COMMENCER
# Lisez le r√©sum√© d'apprentissage : resume_04_advanced_ml.md
# D√©couvrez les techniques ML de pointe avec applications burkinab√® !

println("üìö Consultez le r√©sum√© : modules/module3-ml/resume_04_advanced_ml.md")
println("Appuyez sur Entr√©e quand vous √™tes pr√™t pour le ML expert...")
readline()

println("üß† Machine Learning Avanc√© : Applications Burkina Faso")
println("="^70)

# Installation et importation des paquets
using MLJ, MLJModels, MLJTuning
using DataFrames, CSV, Statistics, Random
using Plots, StatsPlots
using Dates, TimeZones
using LinearAlgebra
using Clustering, MultivariateStats

# Configuration pour reproductibilit√©
Random.seed!(42)
MLJ.color_off()

println("ü§ñ Environnement ML avanc√© configur√©")
println("Seed fix√© √† 42 pour reproductibilit√©")

# Partie 1 : Ensemble Learning pour Pr√©diction Agricole
println("\nüåæ Partie 1 : Ensemble Learning - Rendements Agricoles BF")

# Simulation de donn√©es agricoles r√©alistes pour le Burkina Faso
function g√©n√©rer_donn√©es_agricoles_bf(n_observations=2000)
    println("G√©n√©ration de donn√©es agricoles burkinab√®...")
    
    # R√©gions du Burkina Faso avec caract√©ristiques
    r√©gions = ["Sahel", "Nord", "Centre-Nord", "Centre", "Plateau-Central", 
               "Centre-Est", "Est", "Boucle-Mouhoun", "Hauts-Bassins", 
               "Sud-Ouest", "Centre-Ouest", "Centre-Sud", "Cascades"]
    
    # Types de sol au BF
    sols = ["Ferrugineux", "Vertisol", "Sols-bruns", "Lithosol", "Hydromorphe"]
    
    # Cultures principales
    cultures = ["Mil", "Sorgho", "Ma√Øs", "Riz", "Coton", "Ni√©b√©", "Arachide"]
    
    donn√©es = DataFrame()
    
    for i in 1:n_observations
        r√©gion = rand(r√©gions)
        culture = rand(cultures)
        sol = rand(sols)
        
        # Param√®tres climatiques bas√©s sur la r√©gion
        if r√©gion in ["Sahel", "Nord"]
            pr√©cipitations = 300 + rand() * 400  # 300-700mm (zone sah√©lienne)
            temp√©rature_moy = 28 + rand() * 8     # 28-36¬∞C
        elseif r√©gion in ["Centre", "Plateau-Central"]
            pr√©cipitations = 600 + rand() * 400  # 600-1000mm (zone soudano-sah√©lienne)
            temp√©rature_moy = 26 + rand() * 6     # 26-32¬∞C
        else  # Sud
            pr√©cipitations = 800 + rand() * 600  # 800-1400mm (zone soudanienne)
            temp√©rature_moy = 24 + rand() * 6     # 24-30¬∞C
        end
        
        # Variables agricoles
        superficie = 0.5 + rand() * 4.5  # 0.5-5 hectares (typique petits producteurs BF)
        engrais_kg_ha = rand() < 0.3 ? rand() * 100 : 0  # 30% utilisent engrais
        semences_am√©lior√©es = rand() < 0.2  # 20% utilisent semences am√©lior√©es
        irrigation = rand() < 0.05  # 5% ont irrigation
        
        # Calcul du rendement bas√© sur mod√®le r√©aliste
        rendement_base = Dict(
            "Mil" => 0.8, "Sorgho" => 0.9, "Ma√Øs" => 1.2, "Riz" => 2.5,
            "Coton" => 1.0, "Ni√©b√©" => 0.6, "Arachide" => 1.1
        )[culture]
        
        # Facteurs d'influence sur le rendement
        facteur_pr√©cip = min(2.0, pr√©cipitations / 800)  # Optimal vers 800mm
        facteur_temp = temp√©rature_moy < 30 ? 1.0 : 1.0 - (temp√©rature_moy - 30) * 0.05
        facteur_sol = sol == "Vertisol" ? 1.2 : (sol == "Ferrugineux" ? 1.0 : 0.8)
        facteur_engrais = 1.0 + engrais_kg_ha * 0.005  # Effet engrais
        facteur_semences = semences_am√©lior√©es ? 1.3 : 1.0
        facteur_irrigation = irrigation ? 1.5 : 1.0
        
        # Rendement final avec variabilit√©
        rendement = rendement_base * facteur_pr√©cip * facteur_temp * 
                   facteur_sol * facteur_engrais * facteur_semences * 
                   facteur_irrigation * (0.7 + rand() * 0.6)  # Variabilit√© ¬±30%
        
        push!(donn√©es, (
            r√©gion = r√©gion,
            culture = culture,
            type_sol = sol,
            pr√©cipitations = pr√©cipitations,
            temp√©rature_moyenne = temp√©rature_moy,
            superficie = superficie,
            engrais_kg_ha = engrais_kg_ha,
            semences_am√©lior√©es = semences_am√©lior√©es,
            irrigation = irrigation,
            rendement = max(0.1, rendement)  # Rendement minimum
        ))
    end
    
    return donn√©es
end

# G√©n√©rer le dataset
df_agri = g√©n√©rer_donn√©es_agricoles_bf(2000)

println("Dataset g√©n√©r√© : $(nrow(df_agri)) observations")
println("Variables : $(ncol(df_agri)) features")
println("Rendement moyen : $(round(mean(df_agri.rendement), digits=2)) t/ha")

# Pr√©paration des donn√©es pour ML
println("\nPr√©paration des donn√©es pour ML...")

# Encodage des variables cat√©gorielles
df_ml = copy(df_agri)
df_ml.r√©gion_encoded = categorical(df_ml.r√©gion)
df_ml.culture_encoded = categorical(df_ml.culture)  
df_ml.sol_encoded = categorical(df_ml.type_sol)

# S√©lection des features pour le mod√®le
features = [:r√©gion_encoded, :culture_encoded, :sol_encoded, :pr√©cipitations, 
           :temp√©rature_moyenne, :superficie, :engrais_kg_ha, :semences_am√©lior√©es, :irrigation]

X = select(df_ml, features)
y = df_ml.rendement

# Division train/test
train_idx, test_idx = partition(eachindex(y), 0.8, shuffle=true, rng=42)
X_train, X_test = X[train_idx, :], X[test_idx, :]
y_train, y_test = y[train_idx], y[test_idx]

println("Donn√©es d'entra√Ænement : $(length(train_idx)) observations")
println("Donn√©es de test : $(length(test_idx)) observations")

# Mod√®le 1 : Random Forest
println("\nüå≤ Mod√®le 1 : Random Forest Ensemble")

RandomForestRegressor = @load RandomForestRegressor pkg=DecisionTree
rf_model = RandomForestRegressor(n_trees=100, max_depth=10, min_samples_leaf=5)
rf_machine = machine(rf_model, X_train, y_train)

println("Entra√Ænement Random Forest...")
fit!(rf_machine)

# Pr√©dictions
rf_predictions = predict(rf_machine, X_test)
rf_mae = mean(abs.(rf_predictions - y_test))
rf_rmse = sqrt(mean((rf_predictions - y_test).^2))
rf_r2 = 1 - sum((y_test - rf_predictions).^2) / sum((y_test .- mean(y_test)).^2)

println("Performance Random Forest :")
println("  MAE : $(round(rf_mae, digits=3)) t/ha")
println("  RMSE : $(round(rf_rmse, digits=3)) t/ha") 
println("  R¬≤ : $(round(rf_r2, digits=3))")

# Mod√®le 2 : Gradient Boosting (via MLJ)
println("\nüöÄ Mod√®le 2 : Gradient Boosting")

# Utiliser XGBoost si disponible, sinon AdaBoost
try
    XGBoostRegressor = @load XGBoostRegressor
    gb_model = XGBoostRegressor(max_depth=6, eta=0.1, num_round=100)
    println("Utilisation de XGBoost")
catch
    # Fallback vers un autre mod√®le de boosting
    EvoTreeRegressor = @load EvoTreeRegressor pkg=EvoTrees
    gb_model = EvoTreeRegressor(max_depth=6, eta=0.1, nrounds=100)
    println("Utilisation de EvoTrees")
end

gb_machine = machine(gb_model, X_train, y_train)

println("Entra√Ænement Gradient Boosting...")
fit!(gb_machine)

gb_predictions = predict(gb_machine, X_test)
gb_mae = mean(abs.(gb_predictions - y_test))
gb_rmse = sqrt(mean((gb_predictions - y_test).^2))
gb_r2 = 1 - sum((y_test - gb_predictions).^2) / sum((y_test .- mean(y_test)).^2)

println("Performance Gradient Boosting :")
println("  MAE : $(round(gb_mae, digits=3)) t/ha")
println("  RMSE : $(round(gb_rmse, digits=3)) t/ha")
println("  R¬≤ : $(round(gb_r2, digits=3))")

# Mod√®le 3 : Support Vector Regression
println("\nüìê Mod√®le 3 : Support Vector Regression")

try
    SVMRegressor = @load SVMRegressor pkg=LIBSVM
    svm_model = SVMRegressor(kernel=:rbf, gamma=:scale, C=1.0)
    svm_machine = machine(svm_model, X_train, y_train)
    
    println("Entra√Ænement SVM...")
    fit!(svm_machine)
    
    svm_predictions = predict(svm_machine, X_test)
    svm_mae = mean(abs.(svm_predictions - y_test))
    svm_rmse = sqrt(mean((svm_predictions - y_test).^2))
    svm_r2 = 1 - sum((y_test - svm_predictions).^2) / sum((y_test .- mean(y_test)).^2)
    
    println("Performance SVM :")
    println("  MAE : $(round(svm_mae, digits=3)) t/ha")
    println("  RMSE : $(round(svm_rmse, digits=3)) t/ha")
    println("  R¬≤ : $(round(svm_r2, digits=3))")
    
    svm_available = true
catch e
    println("‚ö†Ô∏è SVM non disponible : $e")
    svm_available = false
    svm_predictions = rf_predictions  # Fallback
end

# Comparaison des mod√®les
println("\nüìä Comparaison des Mod√®les :")
comparaison = DataFrame(
    Mod√®le = ["Random Forest", "Gradient Boosting", svm_available ? "SVM" : "SVM (indisponible)"],
    MAE = [rf_mae, gb_mae, svm_available ? svm_mae : missing],
    RMSE = [rf_rmse, gb_rmse, svm_available ? svm_rmse : missing],
    R2 = [rf_r2, gb_r2, svm_available ? svm_r2 : missing]
)

println(comparaison)

# Partie 2 : Clustering des R√©gions Climatiques
println("\nüó∫Ô∏è Partie 2 : Clustering des R√©gions Climatiques du BF")

# Pr√©parer donn√©es pour clustering
println("Analyse climatique des r√©gions burkinab√®...")

donn√©es_r√©gions = combine(groupby(df_agri, :r√©gion)) do group
    DataFrame(
        pr√©cipitations_moy = mean(group.pr√©cipitations),
        temp√©rature_moy = mean(group.temp√©rature_moyenne),
        rendement_moy = mean(group.rendement),
        usage_engrais = mean(group.engrais_kg_ha),
        superficie_moy = mean(group.superficie)
    )
end

# Ajouter le nom de r√©gion comme premi√®re colonne
donn√©es_r√©gions.r√©gion = unique(df_agri.r√©gion)

# Standardisation pour clustering
using MLJ
Standardizer = @load Standardizer
standardizer = Standardizer()

# S√©lectionner variables pour clustering
vars_clustering = [:pr√©cipitations_moy, :temp√©rature_moy, :rendement_moy, :usage_engrais]
X_cluster = select(donn√©es_r√©gions, vars_clustering)

# Standardiser
std_machine = machine(standardizer, X_cluster)
fit!(std_machine)
X_cluster_std = MLJ.transform(std_machine, X_cluster)

# K-means clustering
println("Application du clustering K-means...")
using Clustering

# Convertir en matrix pour Clustering.jl
X_matrix = Matrix(X_cluster_std)'  # Transpose pour format attendu

# Essayer diff√©rents nombres de clusters
println("Recherche du nombre optimal de clusters...")
max_k = min(8, nrow(donn√©es_r√©gions) - 1)
silhouettes = Float64[]

for k in 2:max_k
    kmeans_result = kmeans(X_matrix, k; maxiter=100)
    
    # Calculer silhouette approximative
    assignments = assignments(kmeans_result)
    
    # Silhouette simplifi√©e (approximation)
    intra_cluster_dist = sum(kmeans_result.totalcost) / nrow(donn√©es_r√©gions)
    silhouette_approx = 1.0 / (1.0 + intra_cluster_dist)
    
    push!(silhouettes, silhouette_approx)
    println("  k=$k : score=$(round(silhouette_approx, digits=3))")
end

# Choisir k optimal
k_optimal = argmax(silhouettes) + 1
println("Nombre optimal de clusters : $k_optimal")

# Clustering final
kmeans_final = kmeans(X_matrix, k_optimal; maxiter=100)
clusters = assignments(kmeans_final)

# Ajouter clusters au DataFrame
donn√©es_r√©gions.cluster = clusters

println("\nR√©sultats du clustering :")
for i in 1:k_optimal
    r√©gions_cluster = donn√©es_r√©gions[donn√©es_r√©gions.cluster .== i, :r√©gion]
    println("  Cluster $i : $(join(r√©gions_cluster, ", "))")
end

# Visualisation du clustering
println("\nVisualisation du clustering...")
scatter_plot = scatter(donn√©es_r√©gions.pr√©cipitations_moy, donn√©es_r√©gions.temp√©rature_moy,
    group=donn√©es_r√©gions.cluster,
    title="üó∫Ô∏è Clustering Climatique des R√©gions - Burkina Faso",
    xlabel="Pr√©cipitations moyennes (mm)",
    ylabel="Temp√©rature moyenne (¬∞C)",
    markersize=8,
    legend=:topright)

# Ajouter labels des r√©gions
for row in eachrow(donn√©es_r√©gions)
    annotate!(row.pr√©cipitations_moy, row.temp√©rature_moy + 0.3,
              text(row.r√©gion, 6, :center))
end

display(scatter_plot)

# Partie 3 : Analyse de S√©ries Temporelles Agricoles
println("\nüìà Partie 3 : S√©ries Temporelles - Production Agricole")

# Simuler donn√©es temporelles de production
println("Simulation de donn√©es temporelles...")

ann√©es = 2010:2023
mois = 1:12
cultures_principales = ["Mil", "Sorgho", "Ma√Øs"]

# G√©n√©rer s√©rie temporelle mensuelle
s√©ries_temporelles = DataFrame()

for culture in cultures_principales
    for ann√©e in ann√©es
        for mois_num in mois
            # Production saisonni√®re (max en saison s√®che pour traitement post-r√©colte)
            saisonnalit√© = mois_num in [11, 12, 1, 2] ? 1.0 : 
                          mois_num in [6, 7, 8, 9] ? 0.1 : 0.5  # Croissance
            
            # Tendance √† long terme
            tendance = 1.0 + (ann√©e - 2010) * 0.02  # 2% croissance annuelle
            
            # Production de base par culture
            prod_base = Dict("Mil" => 1000, "Sorgho" => 800, "Ma√Øs" => 600)[culture]
            
            # Variabilit√© climatique
            variabilit√© = 0.8 + rand() * 0.4
            
            production = prod_base * tendance * saisonnalit√© * variabilit√©
            
            push!(s√©ries_temporelles, (
                date = Date(ann√©e, mois_num, 1),
                culture = culture,
                production = production,
                ann√©e = ann√©e,
                mois = mois_num
            ))
        end
    end
end

# Analyse tendances
println("Analyse des tendances temporelles...")

# Graphique des s√©ries temporelles
ts_plot = plot(title="üìà √âvolution Production Agricole - Burkina Faso",
               xlabel="Ann√©e", 
               ylabel="Production (milliers tonnes)",
               legend=:topleft,
               size=(900, 500))

for culture in cultures_principales
    donn√©es_culture = filter(row -> row.culture == culture, s√©ries_temporelles)
    
    # Agr√©gation annuelle
    prod_annuelle = combine(groupby(donn√©es_culture, :ann√©e),
                           :production => sum => :production_totale)
    
    plot!(prod_annuelle.ann√©e, prod_annuelle.production_totale / 1000,
          label=culture, linewidth=2, marker=:circle, markersize=4)
end

display(ts_plot)

# D√©composition saisonni√®re pour le Mil
println("\nD√©composition saisonni√®re pour le Mil...")

donn√©es_mil = filter(row -> row.culture == "Mil", s√©ries_temporelles)
sort!(donn√©es_mil, :date)

# Moyennes mensuelles sur toutes les ann√©es
saisonnalit√©_mil = combine(groupby(donn√©es_mil, :mois),
                          :production => mean => :production_moyenne)

seasonal_plot = bar(1:12, saisonnalit√©_mil.production_moyenne,
    title="üåæ Saisonnalit√© Production Mil - Burkina Faso",
    xlabel="Mois",
    ylabel="Production Moyenne",
    color=:green,
    legend=false,
    xticks=(1:12, ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]))

display(seasonal_plot)

# Partie 4 : D√©tection d'Anomalies Climatiques
println("\n‚ö†Ô∏è Partie 4 : D√©tection d'Anomalies Climatiques")

# Simuler donn√©es m√©t√©orologiques avec anomalies
println("Simulation de donn√©es m√©t√©o avec anomalies...")

n_jours = 365 * 5  # 5 ans de donn√©es quotidiennes
dates_m√©t√©o = Date(2019, 1, 1):Day(1):Date(2023, 12, 31)

donn√©es_m√©t√©o = DataFrame(
    date = dates_m√©t√©o[1:n_jours],
    temp√©rature = 28 .+ 8 * sin.(2œÄ * (1:n_jours) / 365) .+ randn(n_jours) * 2,
    pr√©cipitations = abs.(randn(n_jours) * 30),  # Pr√©cip al√©atoires positives
    humidit√© = 40 .+ 30 * sin.(2œÄ * (1:n_jours) / 365 + œÄ/2) .+ randn(n_jours) * 5
)

# Ajouter quelques anomalies artificielles
indices_anomalies = rand(1:n_jours, 20)  # 20 jours d'anomalies
donn√©es_m√©t√©o[indices_anomalies, :temp√©rature] .+= randn(20) * 10  # Temp√©ratures extr√™mes
donn√©es_m√©t√©o[indices_anomalies[1:10], :pr√©cipitations] .+= rand(10) * 200  # Fortes pluies

println("Donn√©es m√©t√©o g√©n√©r√©es : $n_jours jours")
println("Anomalies ajout√©es : $(length(indices_anomalies)) jours")

# D√©tection d'anomalies par Z-score
println("\nD√©tection d'anomalies par Z-score...")

function d√©tecter_anomalies_zscore(s√©rie, seuil=3)
    moyenne = mean(s√©rie)
    √©cart_type = std(s√©rie)
    z_scores = abs.((s√©rie .- moyenne) / √©cart_type)
    return z_scores .> seuil
end

# D√©tecter anomalies de temp√©rature
anomalies_temp = d√©tecter_anomalies_zscore(donn√©es_m√©t√©o.temp√©rature)
anomalies_pr√©cip = d√©tecter_anomalies_zscore(donn√©es_m√©t√©o.pr√©cipitations)

nb_anomalies_temp = sum(anomalies_temp)
nb_anomalies_pr√©cip = sum(anomalies_pr√©cip)

println("Anomalies d√©tect√©es :")
println("  Temp√©rature : $nb_anomalies_temp jours")
println("  Pr√©cipitations : $nb_anomalies_pr√©cip jours")

# Visualisation des anomalies
temp_plot = plot(donn√©es_m√©t√©o.date, donn√©es_m√©t√©o.temp√©rature,
    title="üå°Ô∏è Temp√©rature avec Anomalies D√©tect√©es",
    xlabel="Date",
    ylabel="Temp√©rature (¬∞C)",
    label="Temp√©rature",
    color=:blue,
    alpha=0.7)

# Marquer les anomalies
dates_anomalies_temp = donn√©es_m√©t√©o.date[anomalies_temp]
temp_anomalies = donn√©es_m√©t√©o.temp√©rature[anomalies_temp]
scatter!(dates_anomalies_temp, temp_anomalies,
         color=:red, markersize=4, label="Anomalies")

display(temp_plot)

# Partie 5 : Mod√®le Pr√©dictif Multi-Output
println("\nüéØ Partie 5 : Pr√©diction Multi-Output")

# Pr√©parer donn√©es pour pr√©diction simultan√©e de plusieurs cultures
println("Pr√©paration mod√®le multi-output...")

# Features climatiques et agricoles communes
features_communes = [:pr√©cipitations, :temp√©rature_moyenne, :engrais_kg_ha, :irrigation]

# Pr√©parer donn√©es par culture principale
cultures_principales = ["Mil", "Sorgho", "Ma√Øs"]
X_multi = DataFrame()
y_multi = DataFrame()

# Pivot des donn√©es par culture
for (i, obs) in enumerate(eachrow(df_agri))
    if obs.culture in cultures_principales
        if nrow(X_multi) < i
            # Cr√©er nouvelle observation
            push!(X_multi, (
                pr√©cipitations = obs.pr√©cipitations,
                temp√©rature_moyenne = obs.temp√©rature_moyenne,
                engrais_kg_ha = obs.engrais_kg_ha,
                irrigation = obs.irrigation
            ))
            
            # Initialiser rendements √† 0
            new_y = DataFrame()
            for culture in cultures_principales
                new_y[!, "rendement_" * culture] = [0.0]
            end
            if nrow(y_multi) == 0
                y_multi = new_y
            else
                push!(y_multi, new_y[1, :])
            end
        end
        
        # Mettre √† jour le rendement pour cette culture
        if nrow(y_multi) >= i
            col_name = "rendement_" * obs.culture
            if col_name in names(y_multi)
                y_multi[min(nrow(y_multi), i), col_name] = obs.rendement
            end
        end
    end
end

# Nettoyer les donn√©es (garder observations avec au moins une culture)
mask_valide = [any(row[col] > 0 for col in names(y_multi)) for row in eachrow(y_multi)]
X_multi_clean = X_multi[mask_valide, :]
y_multi_clean = y_multi[mask_valide, :]

println("Donn√©es multi-output pr√©par√©es :")
println("  Observations : $(nrow(X_multi_clean))")
println("  Features : $(ncol(X_multi_clean))")
println("  Targets : $(ncol(y_multi_clean))")

if nrow(X_multi_clean) > 50  # S'assurer d'avoir assez de donn√©es
    # Entra√Æner mod√®le multi-output (un mod√®le par culture)
    println("\nEntra√Ænement mod√®les par culture...")
    
    mod√®les_culture = Dict()
    performances_culture = DataFrame()
    
    for culture in cultures_principales
        col_target = "rendement_" * culture
        y_culture = y_multi_clean[!, col_target]
        
        # Filtrer observations avec cette culture
        mask_culture = y_culture .> 0
        if sum(mask_culture) > 20  # Au moins 20 observations
            X_culture = X_multi_clean[mask_culture, :]
            y_culture_filt = y_culture[mask_culture]
            
            # Train/test split
            train_cult, test_cult = partition(eachindex(y_culture_filt), 0.8, shuffle=true, rng=42)
            
            # Mod√®le simple pour cette culture
            model_culture = RandomForestRegressor(n_trees=50)
            machine_culture = machine(model_culture, X_culture, y_culture_filt)
            
            fit!(machine_culture, rows=train_cult)
            
            # √âvaluation
            pred_culture = predict(machine_culture, rows=test_cult)
            actual_culture = y_culture_filt[test_cult]
            
            mae_culture = mean(abs.(pred_culture - actual_culture))
            r2_culture = 1 - sum((actual_culture - pred_culture).^2) / 
                           sum((actual_culture .- mean(actual_culture)).^2)
            
            println("  $culture : MAE=$(round(mae_culture, digits=3)), R¬≤=$(round(r2_culture, digits=3))")
            
            mod√®les_culture[culture] = machine_culture
            
            push!(performances_culture, (
                culture = culture,
                mae = mae_culture,
                r2 = r2_culture,
                n_obs = sum(mask_culture)
            ))
        end
    end
    
    if !isempty(performances_culture)
        println("\nPerformances multi-output :")
        println(performances_culture)
    end
end

# Bilan d'apprentissage
println("\nüìà BILAN D'APPRENTISSAGE")
println("="^70)
println("üß† MA√éTRISE DU MACHINE LEARNING AVANC√â !")
println("="^70)
println("‚úÖ Techniques ML expertises d√©velopp√©es :")
println("  üå≤ Ensemble Learning avec Random Forest et Gradient Boosting")
println("  üìê Support Vector Machines pour r√©gression non-lin√©aire")
println("  üó∫Ô∏è Clustering non-supervis√© pour segmentation r√©gionale")
println("  üìà Analyse de s√©ries temporelles avec d√©composition saisonni√®re")
println("  ‚ö†Ô∏è D√©tection d'anomalies climatiques par m√©thodes statistiques")
println("  üéØ Mod√©lisation multi-output pour pr√©dictions simultan√©es")
println("  üìä √âvaluation comparative avec m√©triques multiples")
println("  üáßüá´ Applications contextualis√©es agriculture burkinab√®")

println("\nüåü BADGE D√âBLOQU√â : 'Expert ML Burkina Faso'")
println("Vous ma√Ætrisez maintenant les techniques avanc√©es pour r√©soudre")
println("des probl√®mes complexes du secteur agricole !")

println("\nüéØ COMP√âTENCES INDUSTRIELLES :")
println("  - Syst√®mes de pr√©diction multi-mod√®les en production")
println("  - Analyse d'anomalies pour alertes pr√©coces")
println("  - Segmentation intelligente de march√©s/r√©gions")
println("  - Optimisation de rendements par zone climatique")

println("\nüöÄ PR√äT POUR L'√âTAPE FINALE !")
println("üìÜ PROCHAINE √âTAPE : 05_python_bridge.jl - Int√©gration Python-Julia")
println("   (Combinez le meilleur des deux √©cosyst√®mes ML)")
println("   (Conseil : Ces mod√®les servent de base aux projets finaux !)")